#!/usr/bin/env ruby
require 'rubygems'

require 'rfc5322.rb'
include Rfc5322

require 'trollop'
require 'unicode'

begin
    config_file = "#{ENV['HOME']}/.rfc5322.yaml"
    config = YAML.load_file(config_file)
    if config == false
        puts "Config empty, trying backup"
        config = YAML.load_file(config_file + ".backup")
    end
rescue
    puts "Could not find #{config_file}"
    exit 1
end
if  config[:accounts] == nil
    puts "No accounts in #{config_file}"
    exit 1
end

opts = Trollop::options do
    opt :account, "Account name", :type => :string
end

# Initialize tweet
tweet ={}

# Doing it this way allows both pipes and args to be active at once
unless STDIN.isatty # i.e. is a pipe. 
    tweet = create_tweet(STDIN.read)
end

# Leftover args are the tweet text
if ARGV.count > 0
    tweet[:status] = ARGV.join(" ")
end

if opts[:account_given]
    tweet[:account] = opts[:account]
end

if tweet[:status] and Unicode::normalize_C(tweet[:status]).length <= 140
    begin
        client = Rfc5322.login(tweet[:account],config)
    rescue
        puts "Could not authenticate #{tweet[:account]}"
        exit 1
    end
    begin
        if tweet[:status][0..1] == "RT" #Retweet
            # If In-Reply-To is set, use that id before Message-ID
            # This is because email clients will usually set that when replying
            # But just working off the Message-ID is good when say, cat email | sendtweet RT
            if tweet[:in_reply_to_status_id]
                client.statuses.retweet! :id=>tweet[:in_reply_to_status_id]
            elsif tweet[:id]
                client.statuses.retweet! :id=>tweet[:id]
            else
                puts "No message id"
                exit 1
            end
        else # normal tweet
            if tweet[:in_reply_to_status_id] 
                client.statuses.update! :status=>tweet[:status], :in_reply_to_status_id=>tweet[:in_reply_to_status_id]
            else # no point sending a blank id
                client.statuses.update! :status=>tweet[:status]
            end
        end
    rescue
        # this assumes that the only time we get a non 200 response is from a bad consumer key
        puts "Unable to continue, please upgrade"
        exit 1
    end
else
    puts "Bad tweet length (#{tweet[:status] ? tweet[:status].length : 0})"
    exit 1
end
